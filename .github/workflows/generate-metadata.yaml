name: Generate Metadata

on:
  workflow_dispatch:
    inputs:
      arch:
        description: 'Architecture to generate metadata for'
        required: false
        type: choice
        default: 'all'
        options:
          - all
          - x86_64-Linux
          - aarch64-Linux

jobs:
  generate:
    name: Generate Metadata
    runs-on: ubuntu-latest
    timeout-minutes: 120

    steps:
      - name: Checkout build-system
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'

      - name: Build buildctl
        run: |
          go build -o buildctl ./cmd/buildctl

      - name: Install dependencies
        run: |
          echo "Installing system dependencies..."
          sudo apt-get update
          sudo apt-get install -y curl wget jq xz-utils zstd sqlite3 minisign

          # Install b3sum
          echo "- Installing b3sum..."
          curl -qfsSL "https://bin.pkgforge.dev/x86_64-Linux/b3sum" -o /tmp/b3sum
          sudo install -m 755 /tmp/b3sum /usr/local/bin/b3sum
          b3sum --version || echo "b3sum installed"

          # Install soarql
          echo "- Installing soarql..."
          ARCH=$(uname -m)
          curl -qfsSL "https://github.com/pkgforge/soarql/releases/download/nightly/soarql-${ARCH}-linux" -o /tmp/soarql
          sudo install -m 755 /tmp/soarql /usr/local/bin/soarql

          # Install oras
          echo "- Installing oras..."
          VERSION="1.2.0"
          curl -LO "https://github.com/oras-project/oras/releases/download/v${VERSION}/oras_${VERSION}_linux_amd64.tar.gz"
          mkdir -p /tmp/oras
          tar -zxf oras_${VERSION}_linux_amd64.tar.gz -C /tmp/oras
          sudo install -m 755 /tmp/oras/oras /usr/local/bin/oras
          oras version

          # Verify minisign
          echo "- Verifying minisign..."
          minisign -v

      - name: Generate metadata
        env:
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
        run: |
          echo "=========================================="
          echo "Generating Metadata"
          echo "=========================================="

          # Create output directory
          mkdir -p artifacts

          # Generate INDEX.json from build results (if database exists)
          if [ -f buildqueue.db ]; then
            echo "Generating INDEX.json..."
            ./buildctl generate --output artifacts
          else
            echo "No build database found, skipping INDEX.json"
          fi

          # Generate bincache metadata
          if [ "${{ inputs.arch }}" = "all" ]; then
            for arch in x86_64-Linux aarch64-Linux; do
              echo ""
              echo "=========================================="
              echo "Generating bincache metadata for $arch..."
              echo "=========================================="
              if ! ./buildctl generate --output artifacts --bincache --arch "$arch" --parallel 10; then
                echo "❌ ERROR: bincache generation failed for $arch"
                echo "Check logs above for details"
              fi
            done
          else
            echo ""
            echo "=========================================="
            echo "Generating bincache metadata for ${{ inputs.arch }}..."
            echo "=========================================="
            if ! ./buildctl generate --output artifacts --bincache --arch "${{ inputs.arch }}" --parallel 10; then
              echo "❌ ERROR: bincache generation failed"
              echo "Check logs above for details"
            fi
          fi

          # Generate pkgcache metadata
          if [ "${{ inputs.arch }}" = "all" ]; then
            for arch in x86_64-Linux aarch64-Linux; do
              echo ""
              echo "=========================================="
              echo "Generating pkgcache metadata for $arch..."
              echo "=========================================="
              if ! ./buildctl generate --output artifacts --pkgcache --arch "$arch" --parallel 10; then
                echo "❌ ERROR: pkgcache generation failed for $arch"
                echo "Check logs above for details"
              fi
            done
          else
            echo ""
            echo "=========================================="
            echo "Generating pkgcache metadata for ${{ inputs.arch }}..."
            echo "=========================================="
            if ! ./buildctl generate --output artifacts --pkgcache --arch "${{ inputs.arch }}" --parallel 10; then
              echo "❌ ERROR: pkgcache generation failed"
              echo "Check logs above for details"
            fi
          fi

          echo ""
          echo "=========================================="
          echo "Generated metadata files"
          echo "=========================================="
          find artifacts -type f | sort

      - name: Fetch SBUILD_LIST.json files
        run: |
          echo ""
          echo "=========================================="
          echo "Fetching SBUILD_LIST.json files"
          echo "=========================================="

          # Fetch from source repos
          echo "Fetching bincache SBUILD_LIST.json..."
          curl -fsSL -o artifacts/bincache-SBUILD_LIST.json \
            "https://raw.githubusercontent.com/pkgforge/bincache/refs/heads/main/SBUILD_LIST.json"

          echo "Fetching pkgcache SBUILD_LIST.json..."
          curl -fsSL -o artifacts/pkgcache-SBUILD_LIST.json \
            "https://raw.githubusercontent.com/pkgforge/pkgcache/refs/heads/main/SBUILD_LIST.json"

          echo ""
          echo "Fetched SBUILD_LIST.json files:"
          ls -lh artifacts/*-SBUILD_LIST.json

      # TODO: Re-enable signing once the password piping issue is resolved
      # - name: Sign all artifacts with minisign
      #   env:
      #     MINISIGN_KEY_CONTENT: ${{ secrets.MINISIGN_PRIVATE_KEY }}
      #     MINISIGN_PASSWORD: ${{ secrets.MINISIGN_PASSWORD }}
      #   run: |
      #     echo ""
      #     echo "=========================================="
      #     echo "Signing all artifacts recursively"
      #     echo "=========================================="
      #
      #     # Find all files in artifacts directory (excluding .sig files)
      #     FILES=$(find artifacts -type f ! -name "*.sig" | sort)
      #
      #     if [ -z "$FILES" ]; then
      #       echo "No files found to sign"
      #       exit 1
      #     fi
      #
      #     echo "Files to sign:"
      #     echo "$FILES"
      #     echo ""
      #
      #     # Sign all files
      #     ./scripts/sign-sbuild-lists.sh $FILES
      #
      #     echo ""
      #     echo "=========================================="
      #     echo "Generated signatures"
      #     echo "=========================================="
      #     find artifacts -type f -name "*.sig" | sort

      - name: Upload metadata artifacts
        uses: actions/upload-artifact@v4
        with:
          name: metadata-artifacts
          path: artifacts/
          retention-days: 7

      - name: Prepare files for release
        run: |
          echo "Flattening directory structure for release upload..."
          mkdir -p release-files

          # Copy and rename files to avoid conflicts
          # INDEX.json and SBUILD_LIST files at root
          [ -f artifacts/INDEX.json ] && cp artifacts/INDEX.json release-files/
          [ -f artifacts/stats.json ] && cp artifacts/stats.json release-files/
          [ -f artifacts/bincache-SBUILD_LIST.json ] && cp artifacts/bincache-SBUILD_LIST.json release-files/
          [ -f artifacts/pkgcache-SBUILD_LIST.json ] && cp artifacts/pkgcache-SBUILD_LIST.json release-files/

          # Slim down GHCR_PKGS.json to just names (if it exists)
          if [ -f artifacts/GHCR_PKGS.json ]; then
            echo "Slimming down GHCR_PKGS.json..."
            jq 'map(.name)' artifacts/GHCR_PKGS.json > release-files/GHCR_PKGS.json
            zstd --ultra -22 --force release-files/GHCR_PKGS.json -o release-files/GHCR_PKGS.json.zstd
            echo "  ✓ Slimmed GHCR_PKGS.json from $(du -h artifacts/GHCR_PKGS.json | cut -f1) to $(du -h release-files/GHCR_PKGS.json | cut -f1)"
          fi

          # Rename bincache files with prefix
          if [ -d artifacts/bincache/data ]; then
            for file in artifacts/bincache/data/*; do
              [ -f "$file" ] && cp "$file" "release-files/bincache-$(basename "$file")"
            done
          fi

          # Rename pkgcache files with prefix
          if [ -d artifacts/pkgcache/data ]; then
            for file in artifacts/pkgcache/data/*; do
              [ -f "$file" ] && cp "$file" "release-files/pkgcache-$(basename "$file")"
            done
          fi

          echo "Files prepared for release:"
          ls -lh release-files/

      - name: Create metadata release
        run: |
          # Generate tag name
          TAG="metadata-$(date -u +%Y-%m-%d-%Hh)"
          echo "Creating release: $TAG"

          # Find all files to upload
          FILES=$(find release-files -type f)

          if [ -z "$FILES" ]; then
            echo "No files found to upload"
            exit 1
          fi

          echo "Files to upload:"
          echo "$FILES"

          # Create release with all metadata files
          gh release create "$TAG" \
            --title "Metadata Release - $(date -u +"%Y-%m-%d %H:00 UTC")" \
            --notes "Automated metadata release from build-system.

          ## Contents
          - \`INDEX.json\` - Full package metadata
          - \`bincache-*.db*\` - Bincache SQLite database (plain, xz, zstd compressed)
          - \`bincache-*.json*\` - Bincache JSON metadata (plain, xz compressed)
          - \`bincache-*.zstd*\` - Bincache zstd compressed data
          - \`pkgcache-*.db*\` - Pkgcache SQLite database (plain, xz, zstd compressed)
          - \`pkgcache-*.json*\` - Pkgcache JSON metadata (plain, xz compressed)
          - \`pkgcache-*.zstd*\` - Pkgcache zstd compressed data
          - \`*-SBUILD_LIST.json\` - Package lists for bincache and pkgcache
          - \`*.bsum\` - BLAKE3 checksums for all files

          Generated at: $(date -u +"%Y-%m-%d %H:%M:%S UTC")" \
            $FILES
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Summary
        if: always()
        run: |
          echo "# Metadata Generation Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Architecture:** ${{ inputs.arch }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Count files
          FILE_COUNT=$(find artifacts -type f | wc -l)
          echo "**Files generated**: $FILE_COUNT" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "## SBUILD_LIST Files" >> $GITHUB_STEP_SUMMARY
          if [ -f artifacts/bincache-SBUILD_LIST.json ]; then
            BINCACHE_COUNT=$(jq '. | length' artifacts/bincache-SBUILD_LIST.json 2>/dev/null || echo "?")
            echo "- ✅ bincache-SBUILD_LIST.json ($BINCACHE_COUNT packages)" >> $GITHUB_STEP_SUMMARY
          fi
          if [ -f artifacts/pkgcache-SBUILD_LIST.json ]; then
            PKGCACHE_COUNT=$(jq '. | length' artifacts/pkgcache-SBUILD_LIST.json 2>/dev/null || echo "?")
            echo "- ✅ pkgcache-SBUILD_LIST.json ($PKGCACHE_COUNT packages)" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "## All Generated Files" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          find artifacts -type f | sort >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
